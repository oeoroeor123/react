<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 
    react 사용을 위한 cdn 링크 추가
    https://ko.legacy.reactjs.org/docs/cdn-links.html
  -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!--
  babel 사용을 위한 cdn 링크 추가
  https://babeljs.io/setup#installation 
  -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <title>Document</title>
</head>
<body>

  <div id="root1"></div>

  <script type="text/babel">

    /*
    코드 설명
    normalNumber와 overheadNumber가 변경될 때 마다 operation1, operation2가 항상 다시 실행됨
    operation2는 비효율적인 연산을 포함하므로, overheadNumber가 변경되지 않아도 불필요하게 실행될 가능성이 있음
    
    → 이를 최적화하기 위해 useMemo를 활용해야 함.
     */
    const operation1 = (n) => {
      return n + 1;
    }

    const operation2 = (n) => {
      for(let i = 0; i < 1999999999; i++); // for문 뒤에 ;로 마무리하면 단독으로 실행된다.
      return n + 1;
    }

    // 컴포넌트 생성
    function UseMemoComp1() {

      const { useState } = React;

      // 첫 번째 state
      const[normalNumber, setNormalNumber] = useState(0);

      // 두 번째 state
      const[overheadNumber, setOverheadNumber] = useState(0);

      // 각 결과값 operation1,2 번에 전달
      const normalResult = operation1(normalNumber);
      const overheadResult = operation2(overheadNumber);

      // 엘리먼트 생성
      return (
        <>
          <h1>정상 계산 활용</h1>
          <input type="number" value={normalNumber} onChange={e => setNormalNumber(Number(e.target.value))}/>
          {/* normalNumber 값에 1을 더하면 결과가 나타난다. */}
          <div>{normalNumber} + 1 = {normalResult}</div>
          <h1>오버헤드 계산 활용</h1>
          <input type="number" value={overheadNumber} onChange={e => setOverheadNumber(Number(e.target.value))}/>
          <div>{overheadNumber} + 1 = {overheadResult}</div>
        </>
      )
    }

    // 렌더링
    // ReactDOM.createRoot(document.getElementById('root1')).render(<UseMemoComp1/>);

  </script>

  <div id="root2"></div>

  <script type="text/babel">

    /*
    코드 설명
    useMemo를 사용하여 overheadOperation(overheadNumber)의 실행을 overheadNumber가 변경될 때만 실행되도록 제한
    normalOperation(normalNumber)도 useMemo를 적용했지만, 이는 단순한 연산이므로 필수가 아님 (문법 익힘용으로 사용!)
    
    불필요한 리렌더링마다 overheadOperation이 실행되는 문제를 해결하여 성능 최적화
    */
    const normalOperation = (n) => {
      return n + 1;
    }

    const overheadOperation = (n) => {
      for(let i = 0; i < 1999999999; i++); // for문 뒤에 ;로 마무리하면 단독으로 실행된다.
      return n + 1;
    }

    // 컴포넌트 생성
    function UseMemoComp2() {

      const { useState, useMemo } = React;

      // 첫 번째 state
      const[normalNumber, setNormalNumber] = useState(0);

      // 두 번째 state
      const[overheadNumber, setOverheadNumber] = useState(0);

      // normalNumber 값이 변하면 다시 수행한다.
      // useMemo에는 오래 걸리는 작업을 넣어 캐싱하는 역할을 수행한다. normalOperation은 오래걸리는 작업은 아니나, 문법 체크용으로 사용했다.
      const normalCachedResult = useMemo(() => {
        return normalOperation(normalNumber);
      }, [normalNumber]);

      // overheadOperation의 경우, 시간이 소요되는 작업이기 때문에 useMeno()를 사용해 값을 캐싱해 놓는다.
      const overheadCachedResult = useMemo(() => {
        return overheadOperation(overheadNumber);
      }, [overheadNumber]);
      
      // 엘리먼트 생성
      return (
        <>
          <h1>정상 계산 활용</h1>
          <input type="number" value={normalNumber} onChange={e => setNormalNumber(Number(e.target.value))}/>
          {/* normalNumber 값에 1을 더하면 결과가 나타난다. */}
          <div>{normalNumber} + 1 = {normalCachedResult}</div>
          <h1>오버헤드 계산 활용</h1>
          <input type="number" value={overheadNumber} onChange={e => setOverheadNumber(Number(e.target.value))}/>
          <div>{overheadNumber} + 1 = {overheadCachedResult}</div>
        </>
      )
    }

    // 렌더링
    ReactDOM.createRoot(document.getElementById('root2')).render(<UseMemoComp2/>);

  </script> 
  
</body>
</html>